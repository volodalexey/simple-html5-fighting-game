{"version":3,"file":"main.bundle.js","mappings":";;;;;;;;;;;AAAA;;;;;;;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACzBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;AC7UA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;AChWA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;AC9CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;AC7GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACvFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;AC5FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;AC9CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AClBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AC7BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AC3BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACPA;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACNA;AACA;AACA;AACA;AACA;;;;;ACJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AEhDA;AACA;AACA;AACA;AACA","sources":["webpack://simple-html5-fighting-game/./src/styles.css","webpack://simple-html5-fighting-game/./src/Collision.ts","webpack://simple-html5-fighting-game/./src/Fighter.ts","webpack://simple-html5-fighting-game/./src/FightingScene.ts","webpack://simple-html5-fighting-game/./src/HealthBar.ts","webpack://simple-html5-fighting-game/./src/LoaderScene.ts","webpack://simple-html5-fighting-game/./src/SceneManager.ts","webpack://simple-html5-fighting-game/./src/StatusBar.ts","webpack://simple-html5-fighting-game/./src/app.ts","webpack://simple-html5-fighting-game/./src/logger.ts","webpack://simple-html5-fighting-game/webpack/bootstrap","webpack://simple-html5-fighting-game/webpack/runtime/chunk loaded","webpack://simple-html5-fighting-game/webpack/runtime/define property getters","webpack://simple-html5-fighting-game/webpack/runtime/global","webpack://simple-html5-fighting-game/webpack/runtime/hasOwnProperty shorthand","webpack://simple-html5-fighting-game/webpack/runtime/make namespace object","webpack://simple-html5-fighting-game/webpack/runtime/node module decorator","webpack://simple-html5-fighting-game/webpack/runtime/jsonp chunk loading","webpack://simple-html5-fighting-game/webpack/before-startup","webpack://simple-html5-fighting-game/webpack/startup","webpack://simple-html5-fighting-game/webpack/after-startup"],"sourcesContent":["// extracted by mini-css-extract-plugin\nexport {};","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Collision = void 0;\nconst logger_1 = require(\"./logger\");\n// eslint-disable-next-line @typescript-eslint/no-extraneous-class\nclass Collision {\n    static checkCollision(a, b) {\n        (0, logger_1.logRectCollision)(`r1:: l=${a.left} r=${a.right} t=${a.top} b=${a.bottom} <> r2:: l=${b.left} r=${b.right} t=${b.top} b=${b.bottom}`);\n        const rightmostLeft = a.left < b.left ? b.left : a.left;\n        const leftmostRight = a.right > b.right ? b.right : a.right;\n        (0, logger_1.logRectCollision)(`left-m-Right=${leftmostRight} right-m-Left=${rightmostLeft}`);\n        if (leftmostRight <= rightmostLeft) {\n            return 0;\n        }\n        const bottommostTop = a.top < b.top ? b.top : a.top;\n        const topmostBottom = a.bottom > b.bottom ? b.bottom : a.bottom;\n        (0, logger_1.logRectCollision)(`bottom-m-Top=${bottommostTop} top-m-Bottom=${topmostBottom}`);\n        if (topmostBottom > bottommostTop) {\n            const squareIntersection = (leftmostRight - rightmostLeft) * (topmostBottom - bottommostTop);\n            const squareTarget = (b.right - b.left) * (b.bottom - b.top);\n            return squareIntersection / squareTarget;\n        }\n        return 0;\n    }\n}\nexports.Collision = Collision;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Fighter = exports.FighterAnimation = void 0;\nconst pixi_js_1 = require(\"pixi.js\");\nconst logger_1 = require(\"./logger\");\nvar FighterAnimation;\n(function (FighterAnimation) {\n    FighterAnimation[\"idle\"] = \"idle\";\n    FighterAnimation[\"run\"] = \"run\";\n    FighterAnimation[\"jump\"] = \"jump\";\n    FighterAnimation[\"fall\"] = \"fall\";\n    FighterAnimation[\"attack\"] = \"attack\";\n    FighterAnimation[\"death\"] = \"death\";\n    FighterAnimation[\"takeHit\"] = \"takeHit\";\n})(FighterAnimation = exports.FighterAnimation || (exports.FighterAnimation = {}));\nclass Fighter extends pixi_js_1.Container {\n    constructor(options) {\n        super();\n        this.isPressed = false;\n        this.directionPressed = {\n            top: false,\n            right: false,\n            bottom: false,\n            left: false\n        };\n        this.spritesScale = 2.5;\n        this.velocity = {\n            vx: 0,\n            vy: 0\n        };\n        this.attackHitAvailable = false;\n        this.attackHitProcessed = false;\n        this.health = 100;\n        this.isDead = false;\n        this.animation = FighterAnimation.idle;\n        this.settings = {\n            animationSpeed: 0.2,\n            attackBoxColor: 0xff00ff\n        };\n        this.attackDamage = options.attackDamage;\n        this.attackFrame = options.attackFrame;\n        this.box = options.box;\n        this.moveSpeed = options.moveSpeed;\n        this.jumpSpeed = options.jumpSpeed;\n        this.setup(options);\n        this.draw(options);\n        this.switchAnimation(FighterAnimation.idle);\n    }\n    setup({ attackOptions, textures: { idleTexture, runTexture, jumpTexture, fallTexture, attackTexture, deathTexture, takeHitTexture } }) {\n        const { settings } = this;\n        this.cullable = true;\n        const spritesBox = new pixi_js_1.Graphics();\n        this.addChild(spritesBox);\n        this.spritesBox = spritesBox;\n        const spritesContainer = new pixi_js_1.Container();\n        const idle = new pixi_js_1.AnimatedSprite(idleTexture);\n        idle.animationSpeed = settings.animationSpeed;\n        spritesContainer.addChild(idle);\n        this.idle = idle;\n        const run = new pixi_js_1.AnimatedSprite(runTexture);\n        run.animationSpeed = settings.animationSpeed;\n        spritesContainer.addChild(run);\n        this.run = run;\n        const jump = new pixi_js_1.AnimatedSprite(jumpTexture);\n        jump.animationSpeed = settings.animationSpeed;\n        spritesContainer.addChild(jump);\n        this.jump = jump;\n        const fall = new pixi_js_1.AnimatedSprite(fallTexture);\n        fall.animationSpeed = settings.animationSpeed;\n        spritesContainer.addChild(fall);\n        this.fall = fall;\n        const attack = new pixi_js_1.AnimatedSprite(attackTexture);\n        attack.animationSpeed = settings.animationSpeed;\n        spritesContainer.addChild(attack);\n        this.attack = attack;\n        const death = new pixi_js_1.AnimatedSprite(deathTexture);\n        death.animationSpeed = settings.animationSpeed;\n        spritesContainer.addChild(death);\n        this.death = death;\n        const takeHit = new pixi_js_1.AnimatedSprite(takeHitTexture);\n        takeHit.animationSpeed = settings.animationSpeed;\n        spritesContainer.addChild(takeHit);\n        this.takeHit = takeHit;\n        this.addChild(spritesContainer);\n        const fighterBox = new pixi_js_1.Graphics();\n        this.addChild(fighterBox);\n        this.fighterBox = fighterBox;\n        const attackBox = new pixi_js_1.Graphics();\n        attackBox.position.x = attackOptions.offset.x;\n        attackBox.position.y = attackOptions.offset.y;\n        this.addChild(attackBox);\n        this.attackBox = attackBox;\n        this.scale.set(this.spritesScale, this.spritesScale);\n    }\n    draw({ attackOptions: { width, height } }) {\n        this.attackBox.beginFill(this.settings.attackBoxColor);\n        this.attackBox.drawRect(0, 0, width, height);\n        this.attackBox.endFill();\n        this.attackBox.alpha = logger_1.logAttackBox.enabled ? 0.5 : 0;\n    }\n    stopAllAnimations() {\n        [this.idle, this.run, this.jump, this.fall, this.attack, this.death, this.takeHit].forEach(spr => {\n            spr.stop();\n        });\n    }\n    hideAllAnimations() {\n        [this.idle, this.run, this.jump, this.fall, this.attack, this.death, this.takeHit].forEach(spr => {\n            spr.visible = false;\n        });\n    }\n    releaseAllPressures() {\n        this.directionPressed.top = false;\n        this.directionPressed.right = false;\n        this.directionPressed.bottom = false;\n        this.directionPressed.left = false;\n    }\n    setTopDirectionPressed(pressed) {\n        if (this.isDead) {\n            return;\n        }\n        this.directionPressed.top = pressed;\n    }\n    setLeftDirectionPressed(pressed) {\n        if (this.isDead) {\n            return;\n        }\n        this.directionPressed.left = pressed;\n    }\n    setRightDirectionPressed(pressed) {\n        if (this.isDead) {\n            return;\n        }\n        this.directionPressed.right = pressed;\n    }\n    setBottomDirectionPressed(pressed) {\n        if (this.isDead) {\n            return;\n        }\n        this.directionPressed.bottom = pressed;\n    }\n    handleMove(pressed, x, y) {\n        const { directionPressed, isDead } = this;\n        if (isDead) {\n            return;\n        }\n        if (typeof pressed === 'boolean') {\n            this.isPressed = pressed;\n        }\n        this.releaseAllPressures();\n        if (this.isPressed) {\n            const { top, right, bottom, left } = this.toBounds();\n            if (x >= right) {\n                directionPressed.right = true;\n            }\n            else if (x <= left) {\n                directionPressed.left = true;\n            }\n            if (y >= bottom) {\n                directionPressed.bottom = true;\n            }\n            else if (y <= top) {\n                directionPressed.top = true;\n            }\n            if (x < right && x > left && y > top && y < bottom) {\n                directionPressed.bottom = true;\n            }\n        }\n    }\n    isAttacking() {\n        return this.animation === FighterAnimation.attack;\n    }\n    isDying() {\n        return this.animation === FighterAnimation.death;\n    }\n    isTakingHit() {\n        return this.animation === FighterAnimation.takeHit;\n    }\n    switchAnimation(animation) {\n        this.hideAllAnimations();\n        this.stopAllAnimations();\n        switch (animation) {\n            case FighterAnimation.idle:\n                this.idle.play();\n                this.idle.visible = true;\n                break;\n            case FighterAnimation.run:\n                this.run.play();\n                this.run.visible = true;\n                break;\n            case FighterAnimation.jump:\n                this.jump.play();\n                this.jump.visible = true;\n                break;\n            case FighterAnimation.fall:\n                this.fall.play();\n                this.fall.visible = true;\n                break;\n            case FighterAnimation.attack:\n                this.attack.play();\n                this.attack.visible = true;\n                this.attack.currentFrame = 0;\n                break;\n            case FighterAnimation.takeHit:\n                this.takeHit.play();\n                this.takeHit.visible = true;\n                this.takeHit.currentFrame = 0;\n                break;\n            case FighterAnimation.death:\n                this.death.play();\n                this.death.visible = true;\n                break;\n        }\n        this.animation = animation;\n    }\n    toBounds() {\n        const midHor = this.x + this.width / 2;\n        const midVer = this.y + this.height / 2;\n        return {\n            top: midVer - this.box.toTop,\n            right: midHor + this.box.toRight,\n            bottom: midVer + this.box.toBottom,\n            left: midHor - this.box.toLeft\n        };\n    }\n    toAttackBounds() {\n        const x = this.x + this.attackBox.x * this.spritesScale;\n        const y = this.y + this.attackBox.y * this.spritesScale;\n        return {\n            top: y,\n            right: x + this.attackBox.width * this.spritesScale,\n            bottom: y + this.attackBox.height * this.spritesScale,\n            left: x\n        };\n    }\n    updateAnimation() {\n        if (this.isDying() || this.isDead) {\n            if (this.death.currentFrame === this.death.totalFrames - 1) {\n                this.death.stop();\n                this.isDead = true;\n            }\n        }\n        else if (this.isAttacking()) {\n            if (this.attack.currentFrame === this.attackFrame && !this.attackHitProcessed) {\n                this.attackHitAvailable = true;\n            }\n            else if (this.attack.currentFrame === this.attack.totalFrames - 1) {\n                this.switchAnimation(Fighter.ANIMATION.idle);\n            }\n        }\n        else {\n            if (this.isTakingHit()) {\n                if (this.takeHit.currentFrame === this.takeHit.totalFrames - 1) {\n                    this.switchAnimation(Fighter.ANIMATION.idle);\n                }\n                // animate take hit\n            }\n            else {\n                this.switchAnimation(Fighter.ANIMATION.idle);\n            }\n            if (this.velocity.vy < 0) {\n                this.switchAnimation(Fighter.ANIMATION.jump);\n            }\n            else if (this.velocity.vy > 0) {\n                this.switchAnimation(Fighter.ANIMATION.fall);\n            }\n            if (this.velocity.vy === 0 && this.velocity.vx !== 0) {\n                this.switchAnimation(Fighter.ANIMATION.run);\n            }\n        }\n        if (!this.isDying() && this.directionPressed.bottom && !this.isAttacking()) {\n            this.directionPressed.bottom = false;\n            this.attackHitAvailable = false;\n            this.attackHitProcessed = false;\n            this.switchAnimation(Fighter.ANIMATION.attack);\n        }\n    }\n    update({ gravity, levelLeft, levelRight, levelBottom }) {\n        if (this.isDead) {\n            return;\n        }\n        if (this.directionPressed.top && this.velocity.vy === 0) {\n            this.velocity.vy = -this.jumpSpeed;\n        }\n        if (this.directionPressed.left) {\n            this.velocity.vx = -this.moveSpeed;\n        }\n        else if (this.directionPressed.right) {\n            this.velocity.vx = this.moveSpeed;\n        }\n        else {\n            this.velocity.vx = 0;\n        }\n        const { bottom, left, right } = this.toBounds();\n        (0, logger_1.logFighterBounds)(`px=${this.x} py=${this.y} ph=${this.height} to-bot=${this.box.toBottom} bot=${bottom}`);\n        if (bottom + this.velocity.vy >= levelBottom) {\n            (0, logger_1.logFighterGravity)(`Floor bot=${bottom} vy=${this.velocity.vy} fl=${levelBottom}`);\n            this.velocity.vy = 0;\n            this.position.y = levelBottom - (this.height / 2 + this.box.toBottom);\n        }\n        else {\n            (0, logger_1.logFighterGravity)(`Gravity bot=${bottom} vy=${this.velocity.vy} fl=${levelBottom}`);\n            this.velocity.vy += gravity;\n            this.position.y += this.velocity.vy;\n        }\n        (0, logger_1.logFighterMove)(`Move left=${left} right=${right} vy=${this.velocity.vx}`);\n        if (left + this.velocity.vx < levelLeft) {\n            this.velocity.vx = 0;\n            this.position.x = levelLeft - (this.width / 2 - this.box.toLeft);\n        }\n        else if (right + this.velocity.vx > levelRight) {\n            this.velocity.vx = 0;\n            this.position.x = levelRight - (this.width / 2 + this.box.toRight);\n        }\n        else {\n            this.position.x += this.velocity.vx;\n        }\n        this.updateAnimation();\n    }\n    takeDamage(damage) {\n        (0, logger_1.logDamage)(`health=${this.health} damage=${damage}`);\n        this.health -= damage;\n        (0, logger_1.logDamage)(`health=${this.health}`);\n        if (this.health <= 0) {\n            this.health = 0;\n            this.releaseAllPressures();\n            this.switchAnimation(FighterAnimation.death);\n        }\n        else {\n            this.switchAnimation(FighterAnimation.takeHit);\n        }\n    }\n}\nexports.Fighter = Fighter;\nFighter.ANIMATION = FighterAnimation;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.FightingScene = void 0;\nconst pixi_js_1 = require(\"pixi.js\");\nconst StatusBar_1 = require(\"./StatusBar\");\nconst Fighter_1 = require(\"./Fighter\");\nconst logger_1 = require(\"./logger\");\nconst Collision_1 = require(\"./Collision\");\nclass FightingScene extends pixi_js_1.Container {\n    constructor(options) {\n        super();\n        this.gravity = 0.7;\n        this.floorY = 480;\n        this.shopSettings = {\n            animationSpeed: 0.1,\n            scale: 2.75,\n            x: 600,\n            y: 128\n        };\n        this.overlaySettings = {\n            color: 0xffffff,\n            alpha: 0.15\n        };\n        this.foregroundSettings = {\n            size: 16,\n            color: 0xffffff\n        };\n        this.player1Options = {\n            initialPosition: {\n                x: 10,\n                y: -100\n            }\n        };\n        this.player2Options = {\n            initialPosition: {\n                x: 400,\n                y: -123\n            }\n        };\n        this.handlePlayer1StartMove = (e) => {\n            this.handlePlayer1Move(this.player1, true, e);\n        };\n        this.handlePlayer1KeepMove = (e) => {\n            this.handlePlayer1Move(this.player1, undefined, e);\n        };\n        this.handlePlayer1StopMove = (e) => {\n            this.handlePlayer1Move(this.player1, false, e);\n        };\n        this.handlePlayer2StartMove = (e) => {\n            this.handlePlayer1Move(this.player2, true, e);\n        };\n        this.handlePlayer2KeepMove = (e) => {\n            this.handlePlayer1Move(this.player2, undefined, e);\n        };\n        this.handlePlayer2StopMove = (e) => {\n            this.handlePlayer1Move(this.player2, false, e);\n        };\n        this.handleKeyDown = (e) => {\n            const { player1, player2 } = this;\n            (0, logger_1.logKeydown)(`${e.code} ${e.key}`);\n            switch (e.code) {\n                case 'KeyW':\n                    player1.setTopDirectionPressed(true);\n                    break;\n                case 'KeyA':\n                    player1.setLeftDirectionPressed(true);\n                    break;\n                case 'KeyS':\n                case 'Space':\n                case 'ShiftLeft':\n                    player1.setBottomDirectionPressed(true);\n                    break;\n                case 'KeyD':\n                    player1.setRightDirectionPressed(true);\n                    break;\n            }\n            switch (e.code) {\n                case 'ArrowUp':\n                    player2.setTopDirectionPressed(true);\n                    break;\n                case 'ArrowLeft':\n                    player2.setLeftDirectionPressed(true);\n                    break;\n                case 'ArrowDown':\n                case 'Numpad0':\n                case 'ShiftRight':\n                    player2.setBottomDirectionPressed(true);\n                    break;\n                case 'ArrowRight':\n                    player2.setRightDirectionPressed(true);\n                    break;\n            }\n        };\n        this.handleKeyUp = (e) => {\n            const { player1, player2 } = this;\n            (0, logger_1.logKeyup)(`${e.code} ${e.key}`);\n            switch (e.code) {\n                case 'KeyW':\n                    player1.setTopDirectionPressed(false);\n                    break;\n                case 'KeyA':\n                    player1.setLeftDirectionPressed(false);\n                    break;\n                case 'KeyS':\n                    player1.setBottomDirectionPressed(false);\n                    break;\n                case 'KeyD':\n                    player1.setRightDirectionPressed(false);\n                    break;\n            }\n            switch (e.code) {\n                case 'ArrowUp':\n                    player2.setTopDirectionPressed(false);\n                    break;\n                case 'ArrowLeft':\n                    player2.setLeftDirectionPressed(false);\n                    break;\n                case 'ArrowDown':\n                    player2.setBottomDirectionPressed(false);\n                    break;\n                case 'ArrowRight':\n                    player2.setRightDirectionPressed(false);\n                    break;\n            }\n        };\n        this.setup(options);\n        this.draw(options);\n        this.setupFighters();\n        this.addEventLesteners();\n    }\n    setup({ viewWidth, viewHeight, player1Textures, player2Textures, textures: { backgroundTexture, shopTexture } }) {\n        this.player1 = new Fighter_1.Fighter({\n            attackDamage: 25,\n            attackFrame: 4,\n            moveSpeed: 5,\n            jumpSpeed: 20,\n            box: {\n                toTop: 70,\n                toRight: 30,\n                toBottom: 55,\n                toLeft: 30\n            },\n            textures: player1Textures,\n            texturesOptions: {\n                offset: {\n                    x: 16,\n                    y: 67\n                }\n            },\n            attackOptions: {\n                offset: {\n                    x: 125,\n                    y: 53\n                },\n                width: 65,\n                height: 66\n            }\n        });\n        this.player2 = new Fighter_1.Fighter({\n            attackDamage: 12,\n            attackFrame: 2,\n            moveSpeed: 6,\n            jumpSpeed: 22,\n            box: {\n                toTop: 70,\n                toRight: 17,\n                toBottom: 70,\n                toLeft: 27\n            },\n            textures: player2Textures,\n            texturesOptions: {\n                offset: {\n                    x: 16,\n                    y: 67\n                }\n            },\n            attackOptions: {\n                offset: {\n                    x: 16,\n                    y: 67\n                },\n                width: 55,\n                height: 60\n            }\n        });\n        const { shopSettings } = this;\n        const background = new pixi_js_1.Sprite(backgroundTexture);\n        this.addChild(background);\n        this.background = background;\n        const shop = new pixi_js_1.AnimatedSprite(shopTexture);\n        shop.animationSpeed = shopSettings.animationSpeed;\n        shop.play();\n        shop.scale.set(shopSettings.scale);\n        shop.position.x = shopSettings.x;\n        shop.position.y = shopSettings.y;\n        this.addChild(shop);\n        this.shop = shop;\n        const overlay = new pixi_js_1.Graphics();\n        this.addChild(overlay);\n        this.overlay = overlay;\n        const statusBar = new StatusBar_1.StatusBar({});\n        this.addChild(statusBar);\n        this.statusBar = statusBar;\n        const foreground = new pixi_js_1.Container();\n        foreground.visible = false;\n        const foregroundText = new pixi_js_1.Text('...', {\n            fontFamily: 'Press Start 2P',\n            fontSize: this.foregroundSettings.size,\n            fill: this.foregroundSettings.color\n        });\n        foregroundText.anchor.set(0.5, 0.5);\n        foregroundText.position.set(this.width / 2, this.height / 2);\n        this.foregroundText = foregroundText;\n        foreground.addChild(foregroundText);\n        this.addChild(foreground);\n        this.foreground = foreground;\n    }\n    draw(_) {\n        this.overlay.beginFill(this.overlaySettings.color);\n        this.overlay.drawRect(0, 0, this.background.width, this.background.height);\n        this.overlay.endFill();\n        this.overlay.alpha = this.overlaySettings.alpha;\n    }\n    setupFighters() {\n        this.addChild(this.player1);\n        this.addChild(this.player2);\n    }\n    handleResize({ viewWidth, viewHeight }) {\n        const availableWidth = viewWidth;\n        const availableHeight = viewHeight;\n        const totalWidth = this.background.width;\n        const totalHeight = this.background.height;\n        let scale = 1;\n        if (totalHeight >= totalWidth) {\n            scale = availableHeight / totalHeight;\n            if (scale * totalWidth > availableWidth) {\n                scale = availableWidth / totalWidth;\n            }\n            (0, logger_1.logLayout)(`By height (sc=${scale})`);\n        }\n        else {\n            scale = availableWidth / totalWidth;\n            (0, logger_1.logLayout)(`By width (sc=${scale})`);\n            if (scale * totalHeight > availableHeight) {\n                scale = availableHeight / totalHeight;\n            }\n        }\n        const occupiedWidth = Math.floor(totalWidth * scale);\n        const occupiedHeight = Math.floor(totalHeight * scale);\n        const x = availableWidth > occupiedWidth ? (availableWidth - occupiedWidth) / 2 : 0;\n        const y = availableHeight > occupiedHeight ? (availableHeight - occupiedHeight) / 2 : 0;\n        (0, logger_1.logLayout)(`aw=${availableWidth} (ow=${occupiedWidth}) x=${x} ah=${availableHeight} (oh=${occupiedHeight}) y=${y}`);\n        this.x = x;\n        this.width = occupiedWidth;\n        this.y = y;\n        this.height = occupiedHeight;\n        (0, logger_1.logLayout)(`x=${x} y=${y} w=${this.width} h=${this.height}`);\n    }\n    handleUpdate(deltaMS) {\n        [this.player1, this.player2].forEach(player => {\n            player.update({\n                gravity: this.gravity,\n                levelLeft: 0,\n                levelRight: this.background.width,\n                levelBottom: this.floorY\n            });\n        });\n        const isAliveBoth = this.player1.health > 0 && this.player2.health > 0;\n        if (isAliveBoth) {\n            this.statusBar.update(deltaMS);\n        }\n        if (isAliveBoth &&\n            this.player1.attackHitAvailable && !this.player1.attackHitProcessed) {\n            this.player1.attackHitProcessed = true;\n            const p1AttackBounds = this.player1.toAttackBounds();\n            const p2Bounds = this.player2.toBounds();\n            const intersectionSquare = Collision_1.Collision.checkCollision(p1AttackBounds, p2Bounds);\n            (0, logger_1.logDamage)(`inter=${intersectionSquare}`);\n            if (intersectionSquare >= 0.05) {\n                this.player2.takeDamage(Math.round(intersectionSquare * this.player1.attackDamage));\n                this.statusBar.updatePlayer2Health(this.player2.health);\n            }\n        }\n        if (isAliveBoth &&\n            this.player2.attackHitAvailable && !this.player2.attackHitProcessed) {\n            this.player2.attackHitProcessed = true;\n            const p2AttackBounds = this.player2.toAttackBounds();\n            const p1Bounds = this.player1.toBounds();\n            const intersectionSquare = Collision_1.Collision.checkCollision(p2AttackBounds, p1Bounds);\n            (0, logger_1.logDamage)(`inter=${intersectionSquare}`);\n            if (intersectionSquare >= 0.05) {\n                this.player1.takeDamage(Math.round(intersectionSquare * this.player2.attackDamage));\n                this.statusBar.updatePlayer1Health(this.player1.health);\n            }\n        }\n        this.checkEndFight();\n    }\n    handleMounted() {\n        Promise.resolve().then(() => {\n            this.startFighters();\n        }).catch(console.error);\n    }\n    startFighters() {\n        const { player1, player1Options, player2, player2Options } = this;\n        player1.position = player1Options.initialPosition;\n        player2.position = player2Options.initialPosition;\n    }\n    addEventLesteners() {\n        this.background.interactive = true;\n        this.on('mousedown', this.handlePlayer1StartMove);\n        this.on('mousemove', this.handlePlayer1KeepMove);\n        this.on('mouseup', this.handlePlayer1StopMove);\n        this.on('touchstart', this.handlePlayer2StartMove);\n        this.on('touchmove', this.handlePlayer2KeepMove);\n        this.on('touchend', this.handlePlayer2StopMove);\n        window.addEventListener('keydown', this.handleKeyDown);\n        window.addEventListener('keyup', this.handleKeyUp);\n    }\n    removeEventListeners() {\n        this.background.interactive = false;\n        this.off('mousedown', this.handlePlayer1StartMove);\n        this.off('mousemove', this.handlePlayer1KeepMove);\n        this.off('mouseup', this.handlePlayer1StopMove);\n        this.off('touchstart', this.handlePlayer2StartMove);\n        this.off('touchmove', this.handlePlayer2KeepMove);\n        this.off('touchend', this.handlePlayer2StopMove);\n        window.removeEventListener('keydown', this.handleKeyDown);\n        window.removeEventListener('keyup', this.handleKeyUp);\n    }\n    handlePlayer1Move(player, pressed, e) {\n        const point = this.background.toLocal(e.global);\n        (0, logger_1.logPointerEvent)(`${e.type} px=${point.x} py=${point.y}`);\n        player.handleMove(pressed, point.x, point.y);\n    }\n    checkEndFight() {\n        if (this.player1.isDying() || this.player2.isDying() || this.statusBar.time <= 0) {\n            this.foreground.visible = true;\n            if (this.player1.health === this.player2.health) {\n                this.foregroundText.text = 'Tie';\n            }\n            else if (this.player1.health > this.player2.health) {\n                this.foregroundText.text = 'Player 1 Wins';\n            }\n            else if (this.player1.health < this.player2.health) {\n                this.foregroundText.text = 'Player 2 Wins';\n            }\n        }\n        if (this.player1.isDead || this.player2.isDead) {\n            this.removeEventListeners();\n        }\n    }\n}\nexports.FightingScene = FightingScene;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.HealthBar = void 0;\nconst pixi_js_1 = require(\"pixi.js\");\nclass HealthBar extends pixi_js_1.Container {\n    constructor(options) {\n        super();\n        this.boxOptions = {\n            border: 0xffffff,\n            borderThick: 4,\n            width: 442,\n            height: 38,\n            fill: 0x818cf8,\n            empty: 0xff0000\n        };\n        this.setup(options);\n        this.draw(options);\n    }\n    setup(_) {\n        this.borderBox = new pixi_js_1.Graphics();\n        this.addChild(this.borderBox);\n        const bars = new pixi_js_1.Container();\n        bars.rotation = Math.PI;\n        bars.position.set(this.boxOptions.width, this.boxOptions.height - this.boxOptions.borderThick);\n        this.emptyBar = new pixi_js_1.Graphics();\n        bars.addChild(this.emptyBar);\n        const fillBar = new pixi_js_1.Graphics();\n        bars.addChild(fillBar);\n        this.fillBar = fillBar;\n        this.addChild(bars);\n    }\n    draw(_) {\n        const { borderBox, boxOptions, fillBar, emptyBar } = this;\n        borderBox.beginFill(boxOptions.border);\n        borderBox.drawRect(0, 0, boxOptions.width, boxOptions.height);\n        borderBox.endFill();\n        emptyBar.beginFill(boxOptions.empty);\n        emptyBar.drawRect(0, 0, boxOptions.width - boxOptions.borderThick, boxOptions.height - 2 * boxOptions.borderThick);\n        emptyBar.endFill();\n        fillBar.beginFill(boxOptions.fill);\n        fillBar.drawRect(0, 0, boxOptions.width - boxOptions.borderThick, boxOptions.height - 2 * boxOptions.borderThick);\n        fillBar.endFill();\n    }\n    setBetween(between) {\n    }\n}\nexports.HealthBar = HealthBar;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.LoaderScene = exports.manifest = void 0;\nconst pixi_js_1 = require(\"pixi.js\");\nconst logger_1 = require(\"./logger\");\nexports.manifest = {\n    bundles: [\n        {\n            name: 'bundle-1',\n            assets: {\n                spritesheet: 'assets/spritesheets/spritesheet.json',\n                background: 'assets/images/background.png',\n                font: 'assets/fonts/Press_Start_2P.woff2'\n            }\n        }\n    ]\n};\nclass LoaderScene extends pixi_js_1.Container {\n    constructor(_) {\n        super();\n        this.barOptions = {\n            width: 350,\n            height: 40,\n            fillColor: 0x008800,\n            borderRadius: 5,\n            borderThick: 5,\n            borderColor: 0x000000\n        };\n        this.downloadProgress = (progressRatio) => {\n            this.loaderBarFill.width = (this.barOptions.width - this.barOptions.borderThick * 2) * progressRatio;\n        };\n        this.setup();\n        this.draw();\n    }\n    setup() {\n        const loaderBarBorder = new pixi_js_1.Graphics();\n        this.addChild(loaderBarBorder);\n        this.loaderBarBorder = loaderBarBorder;\n        const loaderBarFill = new pixi_js_1.Graphics();\n        this.addChild(loaderBarFill);\n        this.loaderBarFill = loaderBarFill;\n    }\n    draw() {\n        const { loaderBarFill, loaderBarBorder, barOptions } = this;\n        loaderBarBorder.beginFill(barOptions.borderColor);\n        loaderBarBorder.drawRoundedRect(0, 0, barOptions.width, barOptions.height, barOptions.borderRadius);\n        loaderBarBorder.endFill();\n        loaderBarFill.beginFill(barOptions.fillColor);\n        loaderBarFill.drawRoundedRect(barOptions.borderThick, barOptions.borderThick, barOptions.width - barOptions.borderThick * 2, barOptions.height - barOptions.borderThick * 2, barOptions.borderRadius);\n        loaderBarFill.endFill();\n    }\n    async initializeLoader() {\n        await pixi_js_1.Assets.init({ manifest: exports.manifest });\n        await pixi_js_1.Assets.loadBundle(exports.manifest.bundles.map(bundle => bundle.name), this.downloadProgress);\n    }\n    getAssets() {\n        return {\n            spritesheet: pixi_js_1.Assets.get('spritesheet'),\n            backgroundTexture: pixi_js_1.Assets.get('background'),\n            font: pixi_js_1.Assets.get('font')\n        };\n    }\n    handleResize({ viewWidth, viewHeight }) {\n        const availableWidth = viewWidth;\n        const availableHeight = viewHeight;\n        const totalWidth = this.width;\n        const totalHeight = this.height;\n        if (availableWidth >= totalWidth && availableHeight >= totalHeight) {\n            const x = availableWidth > totalWidth ? (availableWidth - totalWidth) / 2 : 0;\n            const y = availableHeight > totalHeight ? (availableHeight - totalHeight) / 2 : 0;\n            (0, logger_1.logLayout)(`Spacing aw=${availableWidth} tw=${totalWidth} ah=${availableHeight} th=${totalHeight}`);\n            this.x = x;\n            this.width = this.barOptions.width;\n            this.y = y;\n            this.height = this.barOptions.height;\n        }\n        else {\n            let scale = 1;\n            if (totalHeight >= totalWidth) {\n                scale = availableHeight / totalHeight;\n                if (scale * totalWidth > availableWidth) {\n                    scale = availableWidth / totalWidth;\n                }\n                (0, logger_1.logLayout)(`By height (sc=${scale})`);\n            }\n            else {\n                scale = availableWidth / totalWidth;\n                (0, logger_1.logLayout)(`By width (sc=${scale})`);\n                if (scale * totalHeight > availableHeight) {\n                    scale = availableHeight / totalHeight;\n                }\n            }\n            const occupiedWidth = Math.floor(totalWidth * scale);\n            const occupiedHeight = Math.floor(totalHeight * scale);\n            const x = availableWidth > occupiedWidth ? (availableWidth - occupiedWidth) / 2 : 0;\n            const y = availableHeight > occupiedHeight ? (availableHeight - occupiedHeight) / 2 : 0;\n            (0, logger_1.logLayout)(`aw=${availableWidth} (ow=${occupiedWidth}) ah=${availableHeight} (oh=${occupiedHeight})`);\n            this.x = x;\n            this.width = occupiedWidth;\n            this.y = y;\n            this.height = occupiedHeight;\n        }\n        (0, logger_1.logLayout)(`x=${this.x} y=${this.y} w=${this.width} h=${this.height}`);\n    }\n    handleMounted() {\n    }\n    handleUpdate() {\n    }\n}\nexports.LoaderScene = LoaderScene;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.SceneManager = void 0;\nconst pixi_js_1 = require(\"pixi.js\");\nconst logger_1 = require(\"./logger\");\nclass DefaultScene extends pixi_js_1.Container {\n    handleMounted() {\n    }\n    handleUpdate() {\n    }\n    handleResize() {\n    }\n}\n// eslint-disable-next-line @typescript-eslint/no-extraneous-class\nclass SceneManager {\n    constructor() { }\n    static get width() {\n        // return Math.max(document.documentElement.clientWidth, window.innerWidth ?? 0)\n        return window.innerWidth;\n    }\n    static get height() {\n        // return Math.max(document.documentElement.clientHeight, window.innerHeight ?? 0)\n        return window.innerHeight;\n    }\n    static async initialize() {\n        var _a;\n        const app = new pixi_js_1.Application({\n            autoDensity: true,\n            resolution: (_a = window.devicePixelRatio) !== null && _a !== void 0 ? _a : 1,\n            width: SceneManager.width,\n            height: SceneManager.height,\n            backgroundColor: SceneManager.backgroundColor,\n            resizeTo: window\n        });\n        document.body.appendChild(app.view);\n        if (logger_1.logApp.enabled) {\n            (0, logger_1.logApp)('window.app initialized!');\n            window.app = app;\n        }\n        SceneManager.app = app;\n        SceneManager.setupEventLesteners();\n        // Manager.initializeAssetsPromise = Assets.init({ manifest: manifest });\n        // Manager.initializeAssetsPromise.then(() => Assets.backgroundLoadBundle(manifest.bundles.map(b => b.name)));\n    }\n    static setupEventLesteners() {\n        window.addEventListener('resize', SceneManager.resizeDeBounce);\n        SceneManager.app.ticker.add(SceneManager.updateHandler);\n    }\n    static async changeScene(newScene) {\n        // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions\n        SceneManager.app.stage.removeChild(SceneManager.currentScene);\n        SceneManager.currentScene.destroy();\n        // await Assets.loadBundle(newScene.assetBundles)\n        // we now store it and show it, as it is completely created\n        SceneManager.currentScene = newScene;\n        SceneManager.app.stage.addChild(SceneManager.currentScene);\n        SceneManager.currentScene.handleMounted();\n        SceneManager.resizeHandler();\n    }\n    static resizeDeBounce() {\n        SceneManager.cancelScheduledResizeHandler();\n        SceneManager.scheduleResizeHandler();\n    }\n    static cancelScheduledResizeHandler() {\n        clearTimeout(SceneManager.resizeTimeoutId);\n    }\n    static scheduleResizeHandler() {\n        SceneManager.resizeTimeoutId = setTimeout(() => {\n            SceneManager.cancelScheduledResizeHandler();\n            SceneManager.resizeHandler();\n        }, SceneManager.resizeTimeout);\n    }\n    static resizeHandler() {\n        SceneManager.currentScene.handleResize({\n            viewWidth: SceneManager.width,\n            viewHeight: SceneManager.height\n        });\n    }\n    static updateHandler() {\n        SceneManager.currentScene.handleUpdate(SceneManager.app.ticker.deltaMS);\n    }\n}\nexports.SceneManager = SceneManager;\nSceneManager.currentScene = new DefaultScene();\nSceneManager.resizeTimeout = 300;\nSceneManager.totalWidth = 1024;\nSceneManager.totalHeight = 576;\nSceneManager.backgroundColor = 0xe6e7ea;\n","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.StatusBar = void 0;\nconst pixi_js_1 = require(\"pixi.js\");\nconst gsap_1 = __importDefault(require(\"gsap\"));\nconst HealthBar_1 = require(\"./HealthBar\");\nclass StatusBar extends pixi_js_1.Container {\n    constructor(options) {\n        super();\n        this.barOptions = {\n            padding: 20,\n            healthPadding: 6,\n            healthWidth: 442\n        };\n        this.time = 90 * 1000;\n        this.timerBoxOptions = {\n            textSize: 16,\n            text: 0xffffff,\n            fill: 0x000000,\n            border: 0xffffff,\n            borderThick: 4,\n            width: 100,\n            height: 50\n        };\n        this.setup(options);\n        this.draw(options);\n    }\n    setup(_) {\n        const { barOptions, timerBoxOptions } = this;\n        this.timerBox = new pixi_js_1.Graphics();\n        this.addChild(this.timerBox);\n        const timerText = new pixi_js_1.Text(String(Math.round(this.time / 1000)), {\n            fontFamily: 'Press Start 2P',\n            fontSize: this.timerBoxOptions.textSize,\n            fill: this.timerBoxOptions.text\n        });\n        timerText.anchor.set(0.5, 0.5);\n        timerText.position.set(barOptions.padding + barOptions.healthWidth + timerBoxOptions.width / 2, barOptions.padding + timerBoxOptions.height / 2);\n        this.addChild(timerText);\n        this.timerText = timerText;\n        const player1HealthBar = new HealthBar_1.HealthBar({});\n        player1HealthBar.position.set(barOptions.padding, barOptions.padding + barOptions.healthPadding);\n        this.addChild(player1HealthBar);\n        this.player1HealthBar = player1HealthBar;\n        const player2HealthBar = new HealthBar_1.HealthBar({});\n        player2HealthBar.rotation = Math.PI;\n        player2HealthBar.position.set(barOptions.padding + barOptions.healthWidth * 2 + timerBoxOptions.width, barOptions.padding + barOptions.healthPadding + player2HealthBar.height);\n        this.addChild(player2HealthBar);\n        this.player2HealthBar = player2HealthBar;\n    }\n    draw(_) {\n        const { barOptions, timerBox, timerBoxOptions } = this;\n        timerBox.beginFill(timerBoxOptions.border);\n        timerBox.drawRect(barOptions.padding + barOptions.healthWidth, barOptions.padding, timerBoxOptions.width, timerBoxOptions.height);\n        timerBox.endFill();\n        timerBox.beginFill(timerBoxOptions.fill);\n        timerBox.drawRect(barOptions.padding + barOptions.healthWidth + timerBoxOptions.borderThick, barOptions.padding + timerBoxOptions.borderThick, timerBoxOptions.width - 2 * timerBoxOptions.borderThick, timerBoxOptions.height - 2 * timerBoxOptions.borderThick);\n        timerBox.endFill();\n    }\n    update(deltaMS) {\n        this.time -= deltaMS;\n        if (this.time < 0) {\n            this.time = 0;\n        }\n        this.timerText.text = Math.round(this.time / 1000);\n    }\n    updatePlayer1Health(health) {\n        if (health <= 0) {\n            health = 0;\n        }\n        else if (health >= 100) {\n            health = 100;\n        }\n        gsap_1.default.to(this.player1HealthBar.fillBar, {\n            width: this.player1HealthBar.boxOptions.width * health / 100\n        });\n    }\n    updatePlayer2Health(health) {\n        if (health <= 0) {\n            health = 0;\n        }\n        else if (health >= 100) {\n            health = 100;\n        }\n        gsap_1.default.to(this.player2HealthBar.fillBar, {\n            width: this.player2HealthBar.boxOptions.width * health / 100\n        });\n    }\n}\nexports.StatusBar = StatusBar;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nrequire(\"./styles.css\");\nconst SceneManager_1 = require(\"./SceneManager\");\nconst FightingScene_1 = require(\"./FightingScene\");\nconst LoaderScene_1 = require(\"./LoaderScene\");\nasync function run() {\n    const ellipsis = document.querySelector('.ellipsis');\n    if (ellipsis != null) {\n        ellipsis.style.display = 'none';\n    }\n    await SceneManager_1.SceneManager.initialize();\n    const loaderScene = new LoaderScene_1.LoaderScene({\n        viewWidth: SceneManager_1.SceneManager.width,\n        viewHeight: SceneManager_1.SceneManager.height\n    });\n    await SceneManager_1.SceneManager.changeScene(loaderScene);\n    await loaderScene.initializeLoader();\n    const { backgroundTexture, spritesheet: { animations } } = loaderScene.getAssets();\n    await SceneManager_1.SceneManager.changeScene(new FightingScene_1.FightingScene({\n        viewWidth: SceneManager_1.SceneManager.width,\n        viewHeight: SceneManager_1.SceneManager.height,\n        textures: {\n            backgroundTexture,\n            shopTexture: animations.Shop\n        },\n        player1Textures: {\n            idleTexture: animations['Mack-Idle'],\n            runTexture: animations['Mack-Run'],\n            jumpTexture: animations['Mack-Jump'],\n            fallTexture: animations['Mack-Fall'],\n            attackTexture: animations['Mack-Attack1'],\n            deathTexture: animations['Mack-Death'],\n            takeHitTexture: animations['Mack-Take-Hit']\n        },\n        player2Textures: {\n            idleTexture: animations['Kenji-Idle'],\n            runTexture: animations['Kenji-Run'],\n            jumpTexture: animations['Kenji-Jump'],\n            fallTexture: animations['Kenji-Fall'],\n            attackTexture: animations['Kenji-Attack1'],\n            deathTexture: animations['Kenji-Death'],\n            takeHitTexture: animations['Kenji-Take-Hit']\n        }\n    }));\n}\nrun().catch(console.error);\n","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.logDamage = exports.logKeyup = exports.logKeydown = exports.logFighterMove = exports.logFighterGravity = exports.logFighterBounds = exports.logAttackBox = exports.logPointerEvent = exports.logMoveInterface = exports.logRectCollision = exports.logLayout = exports.logApp = void 0;\nconst debug_1 = __importDefault(require(\"debug\"));\nexports.logApp = (0, debug_1.default)('fighting-app');\nexports.logLayout = (0, debug_1.default)('fighting-layout');\nexports.logRectCollision = (0, debug_1.default)('fighting-rect-collision');\nexports.logMoveInterface = (0, debug_1.default)('fighting-move-interface');\nexports.logPointerEvent = (0, debug_1.default)('fighting-pointer-event');\nexports.logAttackBox = (0, debug_1.default)('fighting-attack-box');\nexports.logFighterBounds = (0, debug_1.default)('fighting-fighter-bounds');\nexports.logFighterGravity = (0, debug_1.default)('fighting-fighter-gravity');\nexports.logFighterMove = (0, debug_1.default)('fighting-fighter-move');\nexports.logKeydown = (0, debug_1.default)('fighting-keydown');\nexports.logKeyup = (0, debug_1.default)('fighting-keyup');\nexports.logDamage = (0, debug_1.default)('fighting-fighter-damage');\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\tid: moduleId,\n\t\tloaded: false,\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Flag the module as loaded\n\tmodule.loaded = true;\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n// expose the modules object (__webpack_modules__)\n__webpack_require__.m = __webpack_modules__;\n\n","var deferred = [];\n__webpack_require__.O = (result, chunkIds, fn, priority) => {\n\tif(chunkIds) {\n\t\tpriority = priority || 0;\n\t\tfor(var i = deferred.length; i > 0 && deferred[i - 1][2] > priority; i--) deferred[i] = deferred[i - 1];\n\t\tdeferred[i] = [chunkIds, fn, priority];\n\t\treturn;\n\t}\n\tvar notFulfilled = Infinity;\n\tfor (var i = 0; i < deferred.length; i++) {\n\t\tvar [chunkIds, fn, priority] = deferred[i];\n\t\tvar fulfilled = true;\n\t\tfor (var j = 0; j < chunkIds.length; j++) {\n\t\t\tif ((priority & 1 === 0 || notFulfilled >= priority) && Object.keys(__webpack_require__.O).every((key) => (__webpack_require__.O[key](chunkIds[j])))) {\n\t\t\t\tchunkIds.splice(j--, 1);\n\t\t\t} else {\n\t\t\t\tfulfilled = false;\n\t\t\t\tif(priority < notFulfilled) notFulfilled = priority;\n\t\t\t}\n\t\t}\n\t\tif(fulfilled) {\n\t\t\tdeferred.splice(i--, 1)\n\t\t\tvar r = fn();\n\t\t\tif (r !== undefined) result = r;\n\t\t}\n\t}\n\treturn result;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.g = (function() {\n\tif (typeof globalThis === 'object') return globalThis;\n\ttry {\n\t\treturn this || new Function('return this')();\n\t} catch (e) {\n\t\tif (typeof window === 'object') return window;\n\t}\n})();","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","__webpack_require__.nmd = (module) => {\n\tmodule.paths = [];\n\tif (!module.children) module.children = [];\n\treturn module;\n};","// no baseURI\n\n// object to store loaded and loading chunks\n// undefined = chunk not loaded, null = chunk preloaded/prefetched\n// [resolve, reject, Promise] = chunk loading, 0 = chunk loaded\nvar installedChunks = {\n\t\"main\": 0\n};\n\n// no chunk on demand loading\n\n// no prefetching\n\n// no preloaded\n\n// no HMR\n\n// no HMR manifest\n\n__webpack_require__.O.j = (chunkId) => (installedChunks[chunkId] === 0);\n\n// install a JSONP callback for chunk loading\nvar webpackJsonpCallback = (parentChunkLoadingFunction, data) => {\n\tvar [chunkIds, moreModules, runtime] = data;\n\t// add \"moreModules\" to the modules object,\n\t// then flag all \"chunkIds\" as loaded and fire callback\n\tvar moduleId, chunkId, i = 0;\n\tif(chunkIds.some((id) => (installedChunks[id] !== 0))) {\n\t\tfor(moduleId in moreModules) {\n\t\t\tif(__webpack_require__.o(moreModules, moduleId)) {\n\t\t\t\t__webpack_require__.m[moduleId] = moreModules[moduleId];\n\t\t\t}\n\t\t}\n\t\tif(runtime) var result = runtime(__webpack_require__);\n\t}\n\tif(parentChunkLoadingFunction) parentChunkLoadingFunction(data);\n\tfor(;i < chunkIds.length; i++) {\n\t\tchunkId = chunkIds[i];\n\t\tif(__webpack_require__.o(installedChunks, chunkId) && installedChunks[chunkId]) {\n\t\t\tinstalledChunks[chunkId][0]();\n\t\t}\n\t\tinstalledChunks[chunkId] = 0;\n\t}\n\treturn __webpack_require__.O(result);\n}\n\nvar chunkLoadingGlobal = self[\"webpackChunksimple_html5_fighting_game\"] = self[\"webpackChunksimple_html5_fighting_game\"] || [];\nchunkLoadingGlobal.forEach(webpackJsonpCallback.bind(null, 0));\nchunkLoadingGlobal.push = webpackJsonpCallback.bind(null, chunkLoadingGlobal.push.bind(chunkLoadingGlobal));","","// startup\n// Load entry module and return exports\n// This entry module depends on other loaded chunks and execution need to be delayed\nvar __webpack_exports__ = __webpack_require__.O(undefined, [\"vendor\"], () => (__webpack_require__(\"./src/app.ts\")))\n__webpack_exports__ = __webpack_require__.O(__webpack_exports__);\n",""],"names":[],"sourceRoot":""}